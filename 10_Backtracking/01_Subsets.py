from typing import List

def subsets(nums: List[int]) -> List[List[int]]:
    res = []
    subset = []

    def dfs(i):
        if i >= len(nums):
            res.append(subset.copy())
            return
        # decision to include nums[i]
        subset.append(nums[i])
        dfs(i + 1)
        # decision NOT to include nums[i]
        subset.pop()
        dfs(i + 1)

    dfs(0)
    return res

nums = [1,2,3]
print(subsets(nums))

"""
もちろん、以下にアルゴリズムの大まかな説明と各部分の説明を行います。

## 大まかな説明:
この関数は、与えられた数のリスト`nums`からそのすべての部分集合(subsets)を生成するものです。この機能は、DFS(深さ優先探索)という再帰的手法を使用しています。主なアイディアは、各数字について、それを部分集合に含めるか含めないかの2つの選択肢があるという事実に基づいています。このアプローチは、DFSを使用してすべての選択肢を網羅的に試すことで、すべての部分集合を生成します。

## 部分毎の説明:

1. **変数の初期化**:
    ```python
    res = []
    subset = []
    ```
   `res`は結果として得られるすべての部分集合を保持するリストです。`subset`は現在の部分集合を保持します。

2. **dfs関数の定義**:
    ```python
    def dfs(i):
    ```
    この内部関数は、`nums`の`i`番目の要素についての選択を行います。

3. **再帰の基本ケース**:
    ```python
    if i >= len(nums):
        res.append(subset.copy())
        return
    ```
    これは再帰の終了条件です。`i`が`nums`の長さ以上になった場合、現在の`subset`を`res`に追加します。

4. **数字を部分集合に含める選択**:
    ```python
    subset.append(nums[i])
    dfs(i + 1)
    ```
    `nums[i]`を`subset`に追加し、次の要素についての決定を行うために`dfs`を再帰的に呼び出します。

5. **数字を部分集合に含めない選択**:
    ```python
    subset.pop()
    dfs(i + 1)
    ```
    先の選択（`nums[i]`を`subset`に追加する選択）を元に戻し、`nums[i]`を部分集合に含めないことを選択します。そして、次の要素についての決定を行うために`dfs`を再帰的に呼び出します。

6. **最初の呼び出し**:
    ```python
    dfs(0)
    ```
    `dfs`関数の初めての呼び出しを行います。この呼び出しは、`nums`の最初の要素（index 0）についての決定を始めることを意味します。

7. **結果の返却**:
    ```python
    return res
    ```
    最後に、すべての部分集合を含む`res`を返します。

このアルゴリズムの美しさは、シンプルでありながら、与えられた数のリストからすべての部分集合を効率的に生成する能力にあります。
"""

"""
はい、`pop`を用いたこの部分は、再帰の理解を深める上で非常に重要です。以下、詳しく説明します。

このアルゴリズムのキーとなる部分は、各要素が部分集合に含まれるか含まれないかの2つの選択肢があるという点です。この2つの選択肢をDFSを用いて全て試すことで、すべての部分集合を生成します。

まず、`dfs`関数内で以下のように要素を`subset`に追加します。

```python
subset.append(nums[i])
dfs(i + 1)
```

上記のコードは、現在の要素（`nums[i]`）を部分集合に追加する選択を意味します。そして、次の要素に対する選択を再帰的に探索します。

しかしこの選択が終わった後（`dfs(i + 1)`の再帰呼び出しが終了した後）、再帰が一つ上のレベルに戻ってきます。このとき、部分集合から最後に追加した要素を取り除くために`pop`を使用します。これにより、`subset`はその前の状態（`nums[i]`を追加する前の状態）に戻ります。

```python
subset.pop()
dfs(i + 1)
```

こうすることで、次に現在の要素を部分集合に含めないという選択を行い、次の要素に対する選択を再帰的に探索することができます。

この`pop`の動作により、再帰の各レベルでの部分集合の状態が正確に維持されるのです。このメカニズムは「バックトラッキング」とも呼ばれるもので、再帰を用いた問題解決の中で非常に一般的なテクニックです。
"""

"""
`nums = [1, 2, 3]` の場合、以下のように `subsets` 関数が動作します：

1. 最初に、`i=0` で `dfs(0)` が呼ばれ、`subset` は空リストとなります。

2. `dfs(0)` が実行されると、最初の要素 `nums[0]`（1）を部分集合に追加する選択肢があります：
    - `subset` は `[1]` になります。
    - 次に、`i=1` で `dfs(1)` が呼ばれます。

3. `dfs(1)` が実行されると、次の要素 `nums[1]`（2）を部分集合に追加する選択肢が考えられます：
    - `subset` は `[1, 2]` になります。
    - それから、`i=2` で `dfs(2)` が呼ばれます。

4. `dfs(2)` が実行されると、最後の要素 `nums[2]`（3）を部分集合に追加する選択肢があります：
    - `subset` は `[1, 2, 3]` になります。
    - すぐ後に、`dfs(3)` が呼ばれますが、`i >= len(nums)` なので、`res` に `subset` のコピーが追加され、`dfs(2)` に戻ります。

5. `dfs(2)` では、3を部分集合に含めない選択も考えられます。そのため、`subset` から3を取り除きます（`pop` の操作）：
    - `subset` は再び `[1, 2]` になります。
    - `dfs(3)` が再度呼ばれ、`res` に `subset` のコピーが追加され、`dfs(1)` に戻ります。

この手順は、すべての要素とその選択肢に対して繰り返されます。最終的には、すべての部分集合が `res` に追加されます。

上記のシミュレーションを完了すると、以下の部分集合が得られます：

```
[]
[1]
[1, 2]
[1, 2, 3]
[1, 3]
[2]
[2, 3]
[3]
```

このように、再帰的にすべての要素とその選択肢を探索することで、リストのすべての部分集合を生成することができます。
"""