class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumSquareDigits(n)
        print(f"slow: {slow}, fast: {fast}")

        while slow != fast:
            fast = self.sumSquareDigits(fast)
            fast = self.sumSquareDigits(fast)
            slow = self.sumSquareDigits(slow)
            print(f"slow: {slow}, fast: {fast}")

        if fast == 1:
            return True
        else:
            return False

    def sumSquareDigits(self, n):
        output = 0
        while n:
            output += (n % 10) ** 2
            n = n // 10
        return output

s = Solution()
n = 19
result = s.isHappy(n)
print(result)


"""
このLeetCodeの練習ロードマップは、ある程度の順序性を持っています。これは主に、以前に学習した概念やスキルを使って次のステップに進むという形で、あるトピックから次のトピックへと進むためのロードマップを形成しています。

1. **Arrays_and_Hashing**: 配列とハッシングは最も基本的なデータ構造で、他の多くのデータ構造やアルゴリズムの基礎となります。

2. **TwoPointers**: これは配列操作によく使われるテクニックです。

3. **Stack**: これは別の基本的なデータ構造で、さまざまな種類の問題解決に使用されます。

4. **BinarySearch**: これは重要なアルゴリズムで、多くの問題で配列や他のデータ構造を効率的に探索するために使用されます。

5. **SlidingWindow**: これも配列やリストに関する問題を解決するための一般的なテクニックです。

以降のトピックも、より複雑なデータ構造やアルゴリズムが取り上げられています。例えば、リンクドリスト、ツリー、トライ、ヒープ、グラフなどです。これらのデータ構造とアルゴリズムは、しばしば一緒に使われるか、あるいは一方が他方の理解に役立つため、この順序で学ぶことは有益です。

しかし、全ての学習者が必ずしもこの順番に従う必要はありません。これはあくまで一つのロードマップであり、学習者の既存の知識や学習スタイルに応じて順番を調整したり、特定のトピックをスキップしたりすることも可能です。
"""

"""
この「二重ポインタ法」を理解するために、レースをイメージしてみてください。二人の走者がいます、一人は"slow"（遅い）走者、もう一人は"fast"（速い）走者だとします。このレースコースは円形で、スタート地点から走り出して同じ地点に戻る形を想像してみてください。

「slow」走者は一度に1歩進むのに対し、「fast」走者は一度に2歩進みます。それぞれが同じ速度で走り続けると、速い走者は遅い走者に追いついて同じ場所に戻ってきますよね。

コードのこの部分では、数列が繰り返し（ループ）しているかどうかを確認しています。繰り返しがある場合、速い走者（ここでは`fast`）は必ず遅い走者（ここでは`slow`）に追いつきます。つまり、`slow`と`fast`が同じになる時点で、繰り返しが存在することがわかるのです。

ですから、「while slow != fast:」の部分では、`slow`と`fast`が同じになるまで、つまり繰り返しが検出されるまで、計算を続けているんです。

この技法は、主に連結リストや配列のようなデータ構造における繰り返し（ループ）の検出に使われます。それはちょうど走者がコースをぐるぐると走り続けるようなものです。
"""

"""
このアルゴリズムは、いわゆる「幸せな数」を見つけるためのものです。数値を取り、その各桁を二乗し、それらを合計するという操作を繰り返し行います。このプロセスが1になる場合、その数値は「幸せな数」であると言います。しかし、プロセスが循環する場合、数値は「幸せ」でないと考えます。

このアルゴリズムは、特定の数値が幸せかどうかを判断するために使用されます。ここでのポイントは、数値が幸せでない場合、その合計のシーケンスが循環する（つまり、同じパターンが繰り返し現れる）ことです。このループを検出するために、二重ポインタ法（fast-slowポインタ法）が使用されます。

slowポインタは1つずつ進み、fastポインタは2つずつ進むというロジックにより、もし数値が幸せでなく、合計のシーケンスが循環する場合、fastポインタはslowポインタに追いつくことになります。つまり、循環が存在する場合、fastとslowはいつかは同じ数値になるはずです。

一方、もし数値が幸せであり、合計が1になる場合、fastポインタが最初に1に到達し、その後、slowポインタも1に到達するでしょう。これにより、fastとslowが同じ（=1）になり、数値が幸せであると判断できます。

したがって、このアルゴリズムは、数値が幸せな数であるかどうかを正しく判断することができます。
"""

"""
このようなアルゴリズムを作成するためには、まず問題を理解し、問題が持つ特性やパターンを探す必要があります。

この問題の場合、まず「幸せな数」が何かを理解することから始まります。それは各桁の二乗和が最終的に1になる数です。次に、二乗和が1にならない数（「不幸せな数」）について考えます。不幸せな数は、二乗和が循環パターンを持つことがわかります。

これを考えると、問題は「どうやって循環パターンを見つけるか」という新しい問題に変わります。この問題には、既知の解法が存在します。それが二重ポインタ法（fast-slowポインタ法）です。

この方法を用いて、二乗和が1になる（幸せな数）か、循環する（不幸せな数）かを効率的に判断することができます。

このように、問題を細かく分解し、既知のパターンや解法を適用することで、新しいアルゴリズムを作り出すことができます。このプロセスには、問題解決スキルと既知のデータ構造やアルゴリズムへの深い理解が必要となります。
"""

"""
「二乗和が循環パターンを持つ」とは、同じ一連の二乗和の計算が何度も繰り返される、つまり循環するということを意味します。

たとえば、数字19から始めて、それぞれの桁の二乗の和を計算してみましょう：

- 1^2 + 9^2 = 82
- 8^2 + 2^2 = 68
- 6^2 + 8^2 = 100
- 1^2 + 0^2 + 0^2 = 1

これにより、最終的に1になり、19は「幸せな数」であることがわかります。しかし、すべての数がこのように1に収束するわけではありません。

例えば、「16」を取り上げてみましょう：

- 1^2 + 6^2 = 37
- 3^2 + 7^2 = 58
- 5^2 + 8^2 = 89
- 8^2 + 9^2 = 145
- 1^2 + 4^2 + 5^2 = 42
- 4^2 + 2^2 = 20
- 2^2 + 0^2 = 4
- 4^2 = 16

ここで、再び16に戻ってきました。つまり、この二乗和の計算が循環している（16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4 -> 16 -> ...）ということがわかります。

このような循環は、「幸せでない数」に特有のものであり、このような数を素早く見つけ出すために「二重ポインタ法」が用いられています。
"""