def numDistinct(s: str, t: str) -> int:
    cache = {}

    for i in range(len(s) + 1):
        cache[(i, len(t))] = 1
    for j in range(len(t)):
        cache[(len(s), j)] = 0

    for i in range(len(s) - 1, -1, -1):
        for j in range(len(t) - 1, -1, -1):
            if s[i] == t[j]:
                cache[(i, j)] = cache[(i + 1, j + 1)] + cache[(i + 1, j)]
            else:
                cache[(i, j)] = cache[(i + 1, j)]
    return cache[(0, 0)]

s = "rabbbit"
t = "rabbit"
numDistinct(s, t)

s = "babgbag"
t = "bag"
numDistinct(s, t)

"""
このコードは、文字列`s`内で文字列`t`が部分文字列として何回現れるかを計算する問題の解決策です。この部分文字列は`s`内の文字を削除することで得られるものです。

以下は、各部分の説明です：

1. **キャッシュの初期化**:
   - `cache = {}`: この辞書は、`s`と`t`の特定の位置の組み合わせで、可能な部分文字列の数をキャッシュします。

2. **初期条件の設定**:
   - `for i in range(len(s) + 1):`: `t`の終端に到達した場合、1通りの方法が存在します（`s`の残りの文字を削除する方法）。
   - `for j in range(len(t)):`: `s`の終端に到達したが、まだ`t`の文字が残っている場合、0通りの方法しか存在しません。

3. **ダイナミックプログラミングの実装**:
   - 外側のループ：`for i in range(len(s) - 1, -1, -1):` は、`s`の最後の文字から先頭の文字へと反対の方向で繰り返します。
   - 内側のループ：`for j in range(len(t) - 1, -1, -1):` は、`t`の最後の文字から先頭の文字へと反対の方向で繰り返します。
     - `if s[i] == t[j]:`: 現在の`s`と`t`の文字が一致する場合、2つの選択肢があります：1つは現在の文字を使用すること、もう1つは使用しないことです。
     - `else:`: 現在の`s`の文字が`t`の文字と一致しない場合、現在の`s`の文字をスキップする必要があります。

4. **結果の返却**:
   - `return cache[(0, 0)]`: `s`と`t`の先頭から始めると、何通りの部分文字列が得られるかを返します。

このアルゴリズムは、`s`と`t`の各文字の位置の組み合わせごとに、`t`が`s`の部分文字列として現れる回数を計算することで、結果を効率的に計算します。
"""