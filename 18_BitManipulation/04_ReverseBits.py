class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            bit = (n >> i) & 1
            res += (bit << (31 - i))
        return res


s = Solution()
n = 0b00000010100101000001111010011100
result = s.reverseBits(n)
print(result)

n = -3
result = s.reverseBits(n)
print(result)

n = 0b1010
result = s.reverseBits(n)
print(result)
"""
この関数は、32ビット整数のビットを逆順にする目的で作られています。具体的には、次のような手順で処理を行います。

1. `def reverseBits(self, n: int) -> int:`: `reverseBits`という関数を定義しています。この関数は引数として32ビット整数`n`を取り、32ビット整数を返すように設定されています。

2. `res = 0`: `res`という変数を作り、初期値を0に設定します。この変数はビットを反転させた結果を保存するためのものです。

3. `for i in range(32):`: 32ビット整数なので、0から31までの32回のループを開始します。

4. `bit = (n >> i) & 1`: 入力された整数`n`を右に`i`ビットシフトします。これにより、`i`番目のビットを最下位に持ってきます。その後、その最下位ビットを取り出すために、ビットAND演算子`&`を使って1とのANDをとります。

5. `res += (bit << (31 - i))`: 取り出したビットを左に`(31 - i)`ビットシフトします。これにより、取り出したビットが元々の位置と逆の位置に移動します。その結果を`res`に加算していきます。

6. `return res`: 最終的に、`res`を返します。これが反転したビットを表現する整数です。

以上がこの関数の説明です。つまり、32ビット整数のビットを1つずつ取り出し、その位置を逆にして新たな整数を作り出す関数となります。
"""

"""
4ビット整数`n=10`（これは二進数では`1010`）を入力として`reverseBits`関数を実行するシミュレーションを示します。まず、この関数は32ビットの整数を反転するため、入力の4ビットの整数も32ビットに拡張します。したがって、`n`は`00000000000000000000000000001010`となります。

以下に4ビットを反転した結果を示します（左端の28ビットはすべて0なので、その部分は省略します）：

初期状態：
res = 00000000000000000000000000000000

i = 0のとき：
bit = (n >> 0) & 1 = 0
res = res + (bit << (31 - 0)) = 00000000000000000000000000000000

i = 1のとき：
bit = (n >> 1) & 1 = 1
res = res + (bit << (31 - 1)) = 01000000000000000000000000000000

i = 2のとき：
bit = (n >> 2) & 1 = 0
res = res + (bit << (31 - 2)) = 01000000000000000000000000000000

i = 3のとき：
bit = (n >> 3) & 1 = 1
res = res + (bit << (31 - 3)) = 01010000000000000000000000000000

最終的な`res`は`1342177280`（これは二進数では`01010000000000000000000000000000`）であり、入力値`n`のビットを反転させたものになっています。
"""