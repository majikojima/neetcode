from typing import List

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)

        for i in range(len(nums)):
            res += i - nums[i]

        return res

s = Solution()
nums = [5,7,9,0,1,3,2,4,6,8]
result = s.missingNumber(nums)
print(result)

"""
この関数は、0から`len(nums)`までの連続する整数が格納されたリスト`nums`から1つだけ欠けている数を見つけるためのものです。具体的には以下のような手順で計算を行っています。

1. `res = len(nums)`: resを`nums`の長さ（つまり、リスト内の最大値+1）に設定します。これは、リスト内に含まれるべきすべての数値の合計（つまり、数列の和）から、実際のリスト内の数値の合計を引くことで欠けている数値を計算するためです。

2. `for i in range(len(nums)):`: `nums`リストの長さ分、ループを回します。ループ内で行う操作は次の通りです。

3. `res += i - nums[i]`: インデックス値`i`から`nums`リストの`i`番目の要素の値を引き、その結果を`res`に加えます。ここで、`i`は`nums`リスト内に含まれるべき値、`nums[i]`は実際のリスト内の値を表します。これにより、リスト内に含まれるべき数値の合計と実際の数値の合計の差（つまり、欠けている数値）を`res`に蓄積していきます。

4. `return res`: ループが終了したら、`res`（つまり、欠けている数値）を返します。この値はリスト内に含まれるべき数値の合計と実際の数値の合計の差を表しています。

つまり、この関数はリスト内に存在するべき数値の合計と実際の数値の合計の差を計算することで、リストから欠けている1つの数値を効率的に見つけることができます。
"""

"""
このアルゴリズムを思いつくためには、以下のような観察や知識が必要です。

1. **問題の理解**: まず、問題が何を求めているのかを深く理解することが大切です。この場合、配列には0からnまでの数が1つだけ欠けて含まれていて、その欠けている数を見つけることが求められています。

2. **パターンの発見**: ここでは、配列の要素が0からnまでの連続した整数であるという点が重要です。これにより、理想的には0からnまでの合計（これは等差数列の和の公式を使って容易に計算できます）と、実際の配列の合計との間の差分が欠けている数であるというパターンを発見できます。

3. **計算量の最適化**: しかし、上記の方法では配列の合計を求めるために一度配列を通し、さらに0からnまでの合計を求めるために再度ループを回す必要があります。これを最適化するために、1つのループでこれらの操作を同時に行う方法を考えます。これが`res += i - nums[i]`という操作につながります。

4. **ビット操作、数学的知識**: また、ビット操作や数学的な知識、プログラミング言語の特性を理解していると、更に効率的なアルゴリズムを考えることができます。

これらの観察や知識は、プログラミングの経験やアルゴリズムの学習、他人のコードを読むことで身につけることができます。また、複雑な問題を単純な部分問題に分割する能力（これを「分割統治法」と言います）も重要です。複雑な問題でも、一歩ずつ分解していくことで解決策を見つけることができます。
"""