from typing import List

def canJump(nums: List[int]) -> bool:
    goal = len(nums) - 1

    for i in range(len(nums) - 2, -1, -1):
        if i + nums[i] >= goal:
            goal = i
    return goal == 0
        
nums = [2,3,1,1,4]
print(canJump(nums))

nums = [3,2,1,0,4]
print(canJump(nums))

"""
このコードは、`nums`という配列の要素が、各位置からジャンプできる最大の距離を示している場合に、配列の先頭から最後までジャンプできるかどうかを判断するためのものです。

**大まかな説明**:
配列の最後の位置から逆順に見ていき、各要素でジャンプできる距離を使って目標位置（初めは配列の最後）まで到達できるかを確認します。もし到達可能なら、その要素を新しい目標として設定します。最終的に先頭位置が目標となった場合、先頭から配列の最後までジャンプできると判断します。

**部分毎の説明**:

1. `goal = len(nums) - 1`
   - `goal`を配列の最後の位置（インデックス）で初期化します。

2. `for i in range(len(nums) - 2, -1, -1):`
   - `nums`配列を逆順にスキャンするためのループです。`len(nums) - 2`から開始して0に到達するまで反復します。

3. `if i + nums[i] >= goal:`
   - 現在の位置`i`から、`nums[i]`の値だけジャンプした場合に、目標位置`goal`に到達するか、もしくは超えるかをチェックします。

4. `goal = i`
   - もし上記の条件が真であれば、現在の位置`i`を新しい目標位置として更新します。これは、`i`から先の部分がジャンプできると確認されたため、次には`i`までどうやってジャンプできるかを確認する必要があるからです。

5. `return goal == 0`
   - この条件で、最初の位置が目標位置として設定されたかどうかを確認します。もし`goal`が0ならば、先頭から配列の最後までジャンプできると判断され、`True`が返されます。それ以外の場合は、`False`が返されます。

このアルゴリズムの計算量はO(n)です。これは、配列の各要素を1回だけ訪れるためです。
"""