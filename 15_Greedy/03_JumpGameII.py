from typing import List

def jump(nums: List[int]) -> bool:
   l, r = 0, 0
   res = 0
   while r < (len(nums) - 1):
      maxJamp = 0
      for i in range(l, r + 1):
         maxJamp = max(maxJamp, i + nums[i])
      l = r + 1
      r = maxJamp
      res += 1
   return res
        
nums = [2,3,1,1,4]
print(jump(nums))

nums = [2,3,0,1,4]
print(jump(nums))

"""
このコードは、`nums`という配列の各要素がその位置からジャンプできる最大の距離を示している場合に、配列の先頭から最後の位置まで到達するための最小のジャンプ数を計算するものです。

**大まかな説明**:
配列を先頭から走査し、現在の範囲（初めは先頭位置のみ）から次にジャンプできる最大の位置を求めます。これを新しい範囲として設定し、再びその範囲からの最大ジャンプ先を求める操作を繰り返します。この操作を配列の最後に到達するまで続け、ジャンプの回数をカウントします。

**部分毎の説明**:

1. `l, r = 0, 0`
   - 現在の探索範囲を示す左端（`l`）と右端（`r`）を初期化します。初めは先頭位置のみを対象とします。

2. `res = 0`
   - ジャンプの回数を保持する変数を初期化します。

3. `while r < (len(nums) - 1):`
   - 右端`r`が配列の最後の位置に到達するまでループを続けます。

4. `maxJump = 0`
   - 現在の範囲から次にジャンプできる最大の位置を求めるための変数を初期化します。

5. `for i in range(l, r + 1):`
   - 現在の探索範囲内で、それぞれの位置からの最大ジャンプ先をチェックするためのループです。

6. `maxJump = max(maxJump, i + nums[i])`
   - 現在の位置`i`からジャンプできる最大の位置と、これまでに求めた`maxJump`の値を比較し、大きい方を`maxJump`に設定します。

7. `l = r + 1`
   - 次の探索範囲の左端を、現在の範囲の右端の次の位置に更新します。

8. `r = maxJump`
   - 次の探索範囲の右端を、`maxJump`の値に更新します。

9. `res += 1`
   - ジャンプの回数を1増やします。

10. `return res`
   - ジャンプの回数を返します。

このアルゴリズムは、"greedy algorithm"（貪欲アルゴリズム）の1つとして知られています。計算量はO(n)で、配列の各要素を1回だけ訪れるためです。
"""