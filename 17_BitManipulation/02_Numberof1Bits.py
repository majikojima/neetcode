class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0

        while n:
            n &= n - 1
            res += 1
        
        return res

s = Solution()
n = 0b00000000000000000000000000001011
result = s.hammingWeight(n)
print(result)

"""
このコードは、引数として渡された整数`n`のビット表現で1となっているビットの数（ハミングウェイト）を返す関数です。この計算は、二進数（ビット）表現に関する特定の性質を利用しています。

以下、各行の説明です：

1. `def hammingWeight(self, n: int) -> int:` メソッドの定義です。引数として整数`n`を受け取り、整数を返します。

2. `res = 0`: `res`は、`n`のビット表現で1となっているビットの数をカウントするための変数です。

3. `while n:` `n`が0になるまでループを続けます。`n`が0になるということは、`n`のビット表現で1がなくなった、つまり全ての1のビットを数え終わったということです。

4. `n &= n - 1`: この操作は、`n`のビット表現で最も低い位置の1を0にします。これは、ビット操作の特性から導かれます。`n - 1`は`n`のビット表現で最も低い位置の1とその右側のビットを反転するので、`n & (n - 1)`の操作により`n`の最も低い位置の1が0になります。

5. `res += 1`: `n`のビット表現で1となっているビットを1つ数えました。

6. `return res`: 1となっているビットを全て数え終わったら、その数（`res`）を返します。

このアルゴリズムは、ビット操作の特性を巧みに利用することで、1のビットの数を効率よく数えることができます。
"""

"""
それは、コンピュータが数値をどのように記憶しているかというビット（0と1）の世界に関する問題です。ビットの世界では、特定のルールやパターンがあります。その一つが、数値から1を引くという操作です。

たとえば、8という数値を考えてみましょう。これはビットで表すと`1000`となります。ここで1を引くと7になりますが、ビットで表すと`0111`となります。つまり、ビット表現では最も低い位置（一番右側）の1を見つけ、その1とそれより右側の全てのビットを反転（1は0に、0は1に）します。

このパターンを利用して、ビット表現で最も低い位置の1を0にする方法を考えてみましょう。それが`n &= n - 1`です。この操作では、「ビットのAND」を使います。ANDは、両方のビットが1の場合にのみ1を返し、それ以外は0を返します。

この操作を使うと、`n`と`n - 1`のビット表現で共通して1となる部分が残ります。そしてその共通部分は、元の`n`のビット表現で最も低い位置の1より左側（大きい側）の1のみとなります。なぜなら、`n - 1`の操作で最も低い位置の1とその右側は全て反転しているからです。

したがって、`n &= n - 1`の操作により、`n`のビット表現で最も低い位置の1が0になります。これを利用すると、ビット表現で1となっているビットの数を効率よく数えることができます。
"""

"""
シミュレーションを行うにはまず、数値をビット表現に変換する必要があります。今回は10という数値を使って説明します。10のビット表現は`1010`です。

この数値に対して、`hammingWeight`関数を適用してみましょう。

1. 最初のwhileループでは、10が0でないのでループが開始されます。
   - `n &= n - 1`を行います。10から1を引くと9になり、そのビット表現は`1001`です。ここで、`n & (n - 1)`を計算すると`1000`、つまり8になります。これは10のビット表現（`1010`）で最も右にある1が0になった結果です。
   - `res`のカウントを1増やします。

2. 次のループでは、`n`は8なのでループが続行されます。
   - `n &= n - 1`を行います。8から1を引くと7になり、そのビット表現は`0111`です。ここで、`n & (n - 1)`を計算すると`0000`、つまり0になります。これは8のビット表現（`1000`）で最も右にある1が0になった結果です。
   - `res`のカウントを1増やします。

3. 次のループでは、`n`は0になったので、whileループは終了します。

この結果、`res`の値は2となります。つまり、10のビット表現には1が2つ含まれているということを示しています。これは元のビット表現を見ても確認できます（`1010`）。
"""

"""
数字をビットに変換すると、`101010`は二進数で表現され、十進数では42となります。`hammingWeight`関数をこの数値に適用してみましょう。

1. 最初のwhileループでは、42（`101010`）が0でないのでループが開始されます。
   - `n &= n - 1`を行います。42から1を引くと41になり、そのビット表現は`101001`です。ここで、`n & (n - 1)`を計算すると`101000`、つまり40（`101000`）になります。これは42のビット表現（`101010`）で最も右にある1が0になった結果です。
   - `res`のカウントを1増やします。

2. 次のループでは、`n`は40なのでループが続行されます。
   - `n &= n - 1`を行います。40から1を引くと39になり、そのビット表現は`100111`です。ここで、`n & (n - 1)`を計算すると`100000`、つまり32（`100000`）になります。これは40のビット表現（`101000`）で最も右にある1が0になった結果です。
   - `res`のカウントを1増やします。

3. 次のループでは、`n`は32なのでループが続行されます。
   - `n &= n - 1`を行います。32から1を引くと31になり、そのビット表現は`011111`です。ここで、`n & (n - 1)`を計算すると`000000`、つまり0になります。これは32のビット表現（`100000`）で最も右にある1が0になった結果です。
   - `res`のカウントを1増やします。

4. 次のループでは、`n`は0になったので、whileループは終了します。

この結果、`res`の値は3となります。つまり、42（`101010`）のビット表現には1が3つ含まれているということを示しています。これは元のビット表現を見ても確認できます（`101010`）。
"""