class TimeMap:

    def __init__(self):
        self.keyStore = {} # key : list of [val, timestamp]

    def set(self, key: str, value: str, timestamp: int) -> None:
        if key not in self.keyStore:
            self.keyStore[key] = []
        self.keyStore[key].append([value, timestamp])

    def get(self, key: str, timestamp: int) -> str:
        res = ""
        values = self.keyStore.get(key, [])
        l, r = 0, len(values) - 1
        while l <= r:
            m = (l + r) // 2
            if values[m][1] <= timestamp:
                res = values[m][0]
                l = m + 1
            else:
                r = m - 1
        return res

# Your TimeMap object will be instantiated and called as such:
obj = TimeMap()
obj.set("foo", "bar", 1)
print(obj.get("foo", 1))
print(obj.get("foo", 3))
obj.set("foo", "bar2", 1)
print(obj.get("foo", 4))
print(obj.get("foo", 5))

"""
このコードは、前述した「タイムスタンプを持つキー-値データ構造」の実装です。具体的な動作を以下に詳述します。

全体的な概要:
- `keyStore`というハッシュマップを使用して、各キーに対して複数の値とタイムスタンプのペアをリストとして保存します。
- `set`メソッドで、特定のキーとタイムスタンプに値を保存します。
- `get`メソッドで、指定されたタイムスタンプまたはそれ以前の最も新しいタイムスタンプでのキーの値を取得します。

部分ごとの説明:
1. `__init__`:
   - `keyStore`というハッシュマップを初期化します。キーは文字列、値は[値, タイムスタンプ]のペアのリストとなります。

2. `set`:
   - 引数としてキー、値、タイムスタンプを受け取ります。
   - そのキーが`keyStore`に存在しない場合、新しいリストを作成します。
   - キーに対応するリストに[値, タイムスタンプ]のペアを追加します。

3. `get`:
   - 引数としてキーとタイムスタンプを受け取ります。
   - 結果として返す値を`res`に保存します。初期値は空文字列です。
   - キーに関連する[値, タイムスタンプ]のペアのリストを取得します。存在しない場合は空のリストを取得します。
   - バイナリサーチを使用して、指定されたタイムスタンプまたはそれ以前の最も新しいタイムスタンプの値を見つけます。該当する値が見つかった場合、`res`を更新します。
   - 最終的に`res`を返します。

このコードのポイントは、`get`メソッドのバイナリサーチ部分です。リストはタイムスタンプの昇順でソートされているため、バイナリサーチを使用して効率的に目的の値を探すことができます。
"""

"""
この問題は、キーとタイムスタンプを元に値を格納・取得するデータ構造を設計するよう求められています。このデータ構造は、同じキーに対して異なるタイムスタンプで複数の値を保存することが可能で、あるタイムスタンプでのキーの値を取得する際に、指定したタイムスタンプ以前で最も新しい値を返す必要があります。

具体的には以下の操作が必要です：

1. `TimeMap()`: データ構造のオブジェクトを初期化します。
2. `set(String key, String value, int timestamp)`: 指定されたタイムスタンプでキーと値を保存します。
3. `get(String key, int timestamp)`: 与えられたタイムスタンプで、またはそれ以前での最も新しいキーの値を取得します。該当する値がない場合は、空文字列 (`""`) を返します。

この問題を解くための一つの方法は、ハッシュマップとソート済みリストを組み合わせて実装することです。ハッシュマップのキーは文字列のキーとして、値はタイムスタンプと値のペアのソート済みリストとして格納することができます。
"""

"""
この`TimeMap`クラスは、タイムスタンプ付きのキー-値ペアのデータ構造を実装しています。それにより、特定のキーの特定の時間における値を取得できるようになっています。このようなデータ構造は、以下のようなシチュエーションやアプリケーションで役立つ可能性があります：

1. **バージョン管理**：オブジェクトやドキュメントの変更履歴を追跡するために、各変更のタイムスタンプを記録することができます。ユーザーは特定の時点でのオブジェクトの状態を取得することができます。

2. **時系列データの分析**：金融、気象学、物流など、特定の時点でのデータの状態を知る必要がある多くの分野で役立ちます。

3. **キャッシュの有効期限**：キャッシュデータが有効な期間をタイムスタンプで追跡し、特定の時間が経過した後にキャッシュを無効にするために使用することができます。

4. **イベントロギングと監査**：システムやアプリケーションのイベントをタイムスタンプ付きで記録し、後で特定の時点での状態やイベントを参照することができます。

5. **状態の復元**：障害が発生した場合や、特定の時点にシステムを戻す必要がある場合に、時点の状態を復元するために使用します。

このクラスの実装は基本的なものであり、実際のプロダクション環境でのニーズに合わせて拡張やカスタマイズが必要な場合がありますが、タイムスタンプ付きのデータを効率的に管理するための基盤として役立ちます。
"""

"""
了解しました。バージョン管理を例に、この`TimeMap`クラスの利用を具体的に説明します。

### シチュエーション：文章のバージョン管理

考えてみてください。オンラインのドキュメントエディタがあり、ユーザーはドキュメントを編集して保存するたびに、そのバージョンを記録したいと思っています。つまり、ユーザーは過去の任意の時点でのドキュメントの内容を参照することができるようにしたいのです。

ここで`TimeMap`の役割が登場します。

### 実装：

1. ユーザーがドキュメントを編集し保存するたびに、そのドキュメントの内容（`value`）とその保存時のタイムスタンプ（`timestamp`）を、ドキュメントのID（`key`）とともに`TimeMap`に保存します。
   
   ```python
   timeMap = TimeMap()
   timeMap.set(document_id, document_content, current_timestamp)
   ```

2. ある時点で、ユーザーが特定のバージョンのドキュメントを参照したいと思ったとき、そのドキュメントのIDとタイムスタンプを指定して、その時点での内容を取得します。

   ```python
   old_version = timeMap.get(document_id, past_timestamp)
   ```

### 結果：

これにより、ユーザーは過去の任意の時点でのドキュメントの内容を取得することができます。また、新しいバージョンが保存されても、古いバージョンは上書きされずにそのまま保存されているため、履歴を追跡することができます。

このように、`TimeMap`はドキュメントやソースコードなどのデジタルアセットの変更履歴を追跡し、特定の時点での状態を容易に参照できるようにするためのシンプルなデータ構造として使用することができます。
"""

"""
了解しました。以下、与えられたコードの挙動に関しての説明を行います。

1. `obj = TimeMap()`: 新しいTimeMapオブジェクトを作成します。
2. `obj.set("foo", "bar", 1)`: キー "foo" にタイムスタンプ 1 で "bar" を保存します。この時点で、`keyStore`は`{"foo": [["bar", 1]]}`となります。
3. `print(obj.get("foo", 1))`: キー "foo" のタイムスタンプ 1 の値を取得すると "bar" が返されます。なので、アウトプットは`bar`です。
4. `print(obj.get("foo", 3))`: キー "foo" のタイムスタンプ 3 の値を取得しますが、タイムスタンプ 3 のデータは存在しないので、タイムスタンプ 1 の "bar" が返されます。アウトプットは`bar`です。
5. `obj.set("foo", "bar2", 1)`: ここで同じキー "foo" と同じタイムスタンプ 1 で新しい値 "bar2" を保存します。この時点で、`keyStore`の中身は`{"foo": [["bar", 1], ["bar2", 1]]}`となります。
6. `print(obj.get("foo", 4))`: キー "foo" のタイムスタンプ 4 の値を取得しますが、タイムスタンプ 4 のデータは存在しないので、最新のデータ "bar2" が返されます。アウトプットは`bar2`です。
7. `print(obj.get("foo", 5))`: 同様に、キー "foo" のタイムスタンプ 5 の値を取得しますが、最新のデータ "bar2" が返されます。アウトプットは`bar2`です。

このコードの動作は、`set`メソッドを使用して同じキーとタイムスタンプで複数回データを設定すると、後に設定したデータが有効になり、前に設定したデータは上書きされます。そして、`get`メソッドは指定されたタイムスタンプまたはそれ以前の最も新しいデータを返します。
"""