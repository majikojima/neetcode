from typing import List

def findMin(nums: List[int]) -> int:
    start, end = 0, len(nums) - 1
    curr_min = float("inf")

    while start < end:
        mid = (start + end) // 2
        curr_min = min(curr_min, nums[mid])

        if nums[mid] > nums[end]:
            start = mid + 1
        else:
            end = mid - 1

    return min(curr_min, nums[start])


nums = [1,2,3,4,5,6,7,8,9]
print(findMin(nums))

"""
このコードは、昇順にソートされた配列が回転された後の配列から最小の要素を効率的に見つけるためのものです。具体的には、二分探索を使用して効率的に最小の要素を探しています。

コードの説明を以下に示します：

1. **変数の初期化**:
   ```python
   start, end = 0, len(nums) - 1
   curr_min = float("inf")
   ```
   - `start`と`end`は、探索する範囲の始点と終点を示すための変数です。
   - `curr_min`は、これまでに見つけた最小の数値を保持する変数です。初期値は無限大に設定されています。

2. **二分探索のループ**:
   ```python
   while start < end:
   ```
   - `start`が`end`よりも小さい間、ループを継続します。

3. **中央のインデックスの計算**:
   ```python
   mid = (start + end) // 2
   ```
   - 現在の探索範囲の中央のインデックスを計算します。

4. **現在の最小値の更新**:
   ```python
   curr_min = min(curr_min, nums[mid])
   ```
   - `mid`の位置の数値と現在の最小値を比較して、より小さい方を`curr_min`に保存します。

5. **探索範囲の更新**:
   ```python
   if nums[mid] > nums[end]:
       start = mid + 1
   else:
       end = mid - 1
   ```
   - もし`mid`の位置の数値が`end`の位置の数値よりも大きければ、最小値は右半分に存在すると判断して、`start`を`mid + 1`に更新します。
   - そうでなければ、最小値は左半分に存在すると判断して、`end`を`mid - 1`に更新します。

6. **最終的な最小値の計算と返却**:
   ```python
   return min(curr_min, nums[start])
   ```
   - 二分探索が終了した後、これまでに見つけた最小値（`curr_min`）と、最後の`start`位置の数値を比較して、より小さい方を返します。

このアルゴリズムは、回転された昇順の配列から最小の要素を効率的に見つけるためのもので、時間複雑度はO(log n)です。
"""

"""
`return min(curr_min, nums[start])` というコードは、2つの値のうち、より小さい方を返す役割を果たします。

具体的には以下の2つの値を比較しています：

1. `curr_min`：これまでの探索中に発見された最小の値。
2. `nums[start]`：最後の探索範囲の始点`start`の位置にある数値。

このコードの意図を理解するために、アルゴリズムの動作を再度考えます。アルゴリズムは、回転された昇順配列の中で最小の要素を探しています。二分探索を使用すると、最後に`start`は最小の要素を指すか、または最小の要素の近くを指す可能性があります。

二分探索のループ中で、`curr_min`は常に更新され、その時点での最小値を保持しています。しかし、ループが終了した後に`start`の位置が最小値を指している可能性もあるため、`curr_min`と`nums[start]`の両方を比較して、実際の最小値を特定しています。

結果として、この`return`文は、配列の中で最小の値を正確に返します。
"""

"""
この問題は、昇順にソートされた配列が1回からn回までの間で回転された結果を考えます。そして、そのように回転された配列が与えられたとき、その配列の最小の要素を見つけることが求められます。

回転された配列において、もともとの最小値の位置が変わることにより、その位置を新たな分岐点（または「回転のポイント」とも呼ぶ）として考えることができます。このポイントの前後で、配列の値はそれぞれ昇順になっています。

この問題をO(log n)の時間複雑度で解くためには、バイナリサーチ（二分探索）を利用します。バイナリサーチを適用することで、配列の中央の値を確認し、それが左側の範囲にあるのか右側の範囲にあるのかを判断します。その結果に応じて、探索の範囲を半分に狭めていき、最小値を効率的に探します。
"""