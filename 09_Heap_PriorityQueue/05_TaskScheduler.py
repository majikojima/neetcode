from collections import deque, Counter
from typing import List
import heapq

def leastInterval(tasks: List[str], n: int) -> int:
    count = Counter(tasks)
    maxHeap = [-cnt for cnt in count.values()]
    heapq.heapify(maxHeap)

    time = 0
    q = deque() # pairs of [-cnt, idleTime]

    while maxHeap or q:
        time += 1
        if maxHeap:
            cnt = 1 + heapq.heappop(maxHeap)
            if cnt:
                q.append([cnt, time + n])

        if q and q[0][1] == time:
            heapq.heappush(maxHeap, q.popleft()[0])
    return time
        
tasks = ["A","A","A","B","B","B"]
n = 2
print(leastInterval(tasks, n))
        
tasks = ["A","A","A","B","B","C","c"]
n = 2
print(leastInterval(tasks, n))

"""
このコードは、CPUがタスクを完了するために必要な最小の時間ユニットを計算するものです。与えられたタスクは同じタイプのものの間にクールダウン期間を持つ必要があります。

コードの大まかな説明:
- タスクの出現回数をカウントして、それに基づいて最大ヒープを作成します。
- タスクを1つずつヒープから取り出し、そのタスクが再実行可能になるまでの時間を待機キューに追加します。
- すべてのタスクが完了するまでこのプロセスを続けます。

部分毎の説明:

1. `count = Counter(tasks)`:
   - タスクの出現回数をカウントします。

2. `maxHeap = [-cnt for cnt in count.values()]`:
   - タスクの出現回数に基づいて最大ヒープを作成するためのリストを生成します。最大ヒープをシミュレートするためには、Pythonの`heapq`では最小ヒープしか提供されていないため、値を逆数にしています。

3. `heapq.heapify(maxHeap)`:
   - リストを最小ヒープに変換します。

4. `time = 0`:
   - 経過時間を0に初期化します。

5. `q = deque() # pairs of [-cnt, idleTime]`:
   - 待機キューを初期化します。このキューは、あるタスクが再実行可能になるまでの時間を追跡します。

6. `while maxHeap or q`:
   - ヒープにタスクが残っているか、または待機キューにタスクがある場合、ループを続けます。

7. `time += 1`:
   - 経過時間を1増やします。

8. `if maxHeap`と`if cnt`:
   - ヒープからタスクを取り出し、そのタスクが再実行可能になるまでの時間を待機キューに追加します。

9. `if q and q[0][1] == time`:
   - タスクが再実行可能になった場合、そのタスクをヒープに戻します。

10. `return time`:
   - すべてのタスクが完了したら、経過時間を返します。

このコードは、与えられたタスクリストに基づいてCPUがどれだけの時間をかけてすべてのタスクを完了するかを計算します。
"""

"""
この問題は、指定されたクールダウン期間`n`を持つCPUスケジューリング問題です。タスクは配列`tasks`で与えられ、同じタスクの間には少なくとも`n`の時間の間隔が必要です。目的は、すべてのタスクを完了するのに必要な最小の時間単位を返すことです。

この問題を解決する一般的な方法は、以下のステップに従います:

1. **タスクの出現回数を数える**: `tasks`配列の各タスクの出現回数を数えるために、ハッシュマップまたはリストを使用します。

2. **最も頻繁に現れるタスクの数を見つける**: タスクの出現回数をソートし、最も頻繁に出現するタスクの数を取得します。これが最終的な解答に影響する主要な要因となります。

3. **最適なスケジュールを構築する**: 最も頻繁に出現するタスクを使用して、最適なスケジュールを構築します。このスケジュールには、クールダウン期間に従ったアイドル時間も含まれる可能性があります。

4. **合計時間を計算する**: 構築したスケジュールに基づいて、すべてのタスクを完了するのに必要な合計時間を計算します。

これらのステップをコードに落とし込むことで、問題の答えを見つけることができます。
"""

"""
了解しました。具体例を通じて上記のコードの動作をシミュレーションしてみましょう。

**例**:
- `tasks = ["A", "A", "A", "B", "B", "B"]`
- `n = 2` (同じタスクの間に最低2ユニットのクールダウン期間が必要)

この場合、タスクAとタスクBはそれぞれ3回ずつ現れるので、最も効率的な実行順序は以下の通りです: 
`A -> B -> idle -> A -> B -> idle -> A -> B`

**シミュレーション**:
1. タスクの出現回数をカウント: `A: 3`, `B: 3`
2. ヒープを作成: `maxHeap = [-3, -3]` (最大ヒープをシミュレートするための逆数)
3. `time = 0`, `q = deque()`

最初のループ:
- タスクAを取り出す: `maxHeap = [-3]` -> `maxHeap = [-2]`
- 待機キューに追加: `q = [(A, 3)]` (タスクAはtime=3まで再実行できない)
- `time = 1`

次のループ:
- タスクBを取り出す: `maxHeap = [-2]` -> `maxHeap = [-1]`
- 待機キューに追加: `q = [(A, 3), (B, 4)]` (タスクBはtime=4まで再実行できない)
- `time = 2`

次のループ:
- ヒープが空なので、次に再実行可能なタスクまで時間をジャンプ: `time = 3`

次のループ:
- タスクAを取り出す: `maxHeap = [-1, -2]`
- 待機キューに追加: `q = [(B, 4), (A, 6)]`
- `time = 4`

以降も同様の手順で実行を続け、最終的に `time = 8` となります。

このシミュレーションは、与えられたコードがどのようにして効率的なタスクの実行順序を計算するかを示しています。
"""