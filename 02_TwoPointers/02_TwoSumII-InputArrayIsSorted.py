from typing import List

def twoSum(numbers: List[int], target: int) -> List[int]:
    l, r = 0, len(numbers) - 1

    while l < r:
        curSum = numbers[l] + numbers[r]
        if curSum > target:
            r -= 1
        elif curSum < target:
            l += 1
        else:
            return [l+1, r+1]
    return []

numbers = [2,7,11,15]
target = 18
print(twoSum(numbers, target))

"""
このコードは、ソート済みの整数のリスト`numbers`とターゲットの整数`target`を入力として受け取り、その2つの数の合計がターゲットと等しい2つの数のインデックスを返す関数`twoSum`を定義しています。このインデックスは1から始まるため、0から始まる通常のPythonのインデックスよりも1つ大きいです。

大まかな説明:
ソート済みのリスト`numbers`内の2つの数の合計がターゲット`target`に等しい場合の、その2つの数のインデックスを返します。2つのポインタ`l`と`r`を使用してリストを走査し、合計がターゲットと等しいか、それより大きいか、小さいかに基づいてポインタを調整します。

部分毎の説明:

1. `l, r = 0, len(numbers) - 1`:
   - リスト`numbers`の最初の要素のインデックス`l`と最後の要素のインデックス`r`を初期化します。

2. `while l < r`:
   - `l`が`r`より小さい間、ループを続けます。これは、2つのポインタが交差しない限りリストを走査し続けることを意味します。

3. `curSum = numbers[l] + numbers[r]`:
   - 現在の`l`と`r`のポインタの位置にある2つの数の合計を計算します。

4. `if curSum > target:`:
   - 現在の合計がターゲットより大きい場合、`r`のポインタを1つ減らして合計を小さくします。

5. `elif curSum < target:`:
   - 現在の合計がターゲットより小さい場合、`l`のポインタを1つ増やして合計を大きくします。

6. `else:`:
   - それ以外の場合（`curSum`が`target`と等しい場合）、`l`と`r`の位置のインデックスを1ずつ増やして返します。これは、要求されているインデックスが1から始まるためです。

このアルゴリズムは、2つのポインタがリストの異なる方向に移動することで、効率的に正しい組み合わせを見つけることができます。
"""

"""
このようなアルゴリズムを自ら考えるためには、次のステップや考え方を採用することが有効です：

1. **問題の理解**:
   - 問題をしっかりと読み、どのような条件や制約が存在するのかを理解します。
   - この場合、`numbers`はソート済みであるという情報は非常に重要です。

2. **基本的な解法から始める**:
   - 最初に、ブルートフォースのアプローチ（すべての組み合わせを試す方法など）を考えます。
   - これにより、問題の本質や求められる解答の形式を理解する手助けとなります。

3. **最適化を考える**:
   - 基本的な解法は効率的でない場合が多いので、最適化の方法を考えます。
   - この問題では、`numbers`がソート済みであることを利用して、2つのポインタを使う方法が考えられます。

4. **特性やパターンを利用する**:
   - ソート済みのリストには、小さい値が前に、大きい値が後に配置されているという特性があります。
   - この特性を利用して、2つのポインタをリストの前後から移動させることで、効率的に目的の合計値を探索できます。

5. **実験やテスト**:
   - 考えたアプローチを少数のサンプルデータや手計算でテストします。
   - これにより、アプローチの妥当性を確認できるだけでなく、改善点や新しいアイディアが浮かぶこともあります。

6. **過去の経験や知識を利用する**:
   - 以前に似たような問題やパターンに遭遇した経験があれば、それを参考にします。
   - この`twoSum`の問題は、ソートされていないリストに対するバージョンも存在します。そのような問題の解法やアプローチを知っていれば、この問題の解法にアイディアを得ることができます。

7. **反復練習**:
   - アルゴリズムやデータ構造に関する問題を定期的に解くことで、さまざまな問題解決のテクニックやパターンを身につけることができます。

アルゴリズムやデータ構造の問題を解く能力は、経験と練習によって向上します。繰り返し問題を解いて、さまざまなアプローチや手法を試すことで、自分自身の問題解決のスキルを磨くことができます。
"""