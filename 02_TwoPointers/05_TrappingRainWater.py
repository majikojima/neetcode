from typing import List

def trap(height: List[int]) -> int:
    if not height:
      return 0
   
    l, r = 0, len(height) - 1
    leftMax, rightMax = height[l], height[r]
    res = 0

    while l < r:
      if leftMax < rightMax:
        l += 1
        leftMax = max(leftMax, height[l])
        res += leftMax - height[l]
      else:
        r -= 1
        rightMax = max(rightMax, height[r])
        res += rightMax - height[r]
    return res

height = [0,1,0,2,1,0,1,3,2,1,2,1]
print(trap(height))

"""
このコードは、バーの間にたまる雨水の量を計算する問題の解法を提供します。水は、バーの間の低い部分にたまるため、最大の高さのバーを左右から探索して、それぞれの位置で水がどれだけたまるかを計算します。

**大まかな説明**:
- このアルゴリズムは、二つのポインタを使用して、高さリストの左端と右端から中央に向かって探索します。
- 左と右のポインタの現在の最大高さをトラッキングします。
- どちらのポインタの現在の高さが低いかに基づいて、水がその位置にたまるかどうかを判断し、結果に追加します。

**部分毎の説明**:

1. `if not height: return 0`: 
   - heightが空の場合、たまる水はないので、0を返します。

2. `l, r = 0, len(height) - 1`: 
   - lとrは、高さリストの左端と右端のインデックスを指します。

3. `leftMax, rightMax = height[l], height[r]`: 
   - 左と右のポインタの現在の最大高さを初期化します。

4. `while l < r`:
   - lがrよりも小さい間、ループを続けます。

5. `if leftMax < rightMax`:
   - もし`leftMax`が`rightMax`よりも小さい場合、水は`leftMax`に制限されるため、左のポインタを中心に向かって移動します。
   - `l += 1`: 左のポインタを1つ進めます。
   - `leftMax = max(leftMax, height[l])`: 新しい左のポインタの高さを確認し、必要に応じて`leftMax`を更新します。
   - `res += leftMax - height[l]`: この位置にたまる水の量（`leftMax`と現在の高さの差）を結果に追加します。

6. `else`:
   - `leftMax`が`rightMax`よりも大きいか等しい場合、右のポインタを中心に向かって移動します。
   - `r -= 1`: 右のポインタを1つ戻します。
   - `rightMax = max(rightMax, height[r])`: 新しい右のポインタの高さを確認し、必要に応じて`rightMax`を更新します。
   - `res += rightMax - height[r]`: この位置にたまる水の量（`rightMax`と現在の高さの差）を結果に追加します。

7. `return res`: 
   - ループが完了したら、たまった水の合計量（res）を返します。
"""

"""
このアルゴリズム（`trap`関数）は、"Trapping Rain Water"という有名な問題に対する一つの解法です。この問題は、バケットのような高さの配列が与えられたときに、どれだけの雨水をトラップできるかを計算するものです。この問題を解くためのアルゴリズムを設計する過程は以下のようになります：

1. **理解**:
   - 問題を深く理解することから始めます。この場合、各バーの間にどれだけの水が貯まるかを理解するためには、そのバーの左と右の最大の高さを知る必要があります。

2. **単純なアプローチの検討**:
   - 一つの方法は、各バーについて、左と右の最大の高さを見つけることです。しかし、この方法は時間的に効率的ではありません（O(n^2)の時間複雑度がかかる）。

3. **最適化の考察**:
   - 効率的なアプローチを考えるために、双方向からのスキャンを考慮します。このアイデアは、2つのポインタを使用して配列の両端から中央に向かってスキャンすることで、各バーの左と右の最大の高さを効率的に計算するものです。

4. **実装**:
   - 2つのポインタ`l`と`r`を使用して、配列の左端と右端からスタートします。
   - `leftMax`と`rightMax`を使用して、`l`と`r`の位置での左と右の最大の高さを追跡します。
   - `l`の位置のバーの高さが`r`の位置のバーの高さよりも低い場合、`l`を右に移動させ、その位置での水の量（`leftMax - height[l]`）を結果に追加します。
   - 逆の場合、`r`を左に移動させ、その位置での水の量を結果に追加します。

5. **テストとデバッグ**:
   - アルゴリズムをいくつかのテストケースでテストして、期待される結果が得られるかを確認します。

このように、問題の深い理解から始めて、効率的な解法をステップバイステップで設計していくことで、このアルゴリズムを作成することができます。
"""

"""
了解しました！小学生向けの説明を試みますね。

---

想像してみてください。あなたが砂場で遊んでいて、色んな高さの砂の山を作ったとします。そして、水を流し込むと、砂の山の間に水がたまりますね。どこにどれだけ水がたまるのかを知りたいと思ったら、どうやって調べますか？

1つの方法は、一番左の山から始めて、次の山が出てくるまでの間に水がどれだけたまるかを調べることです。そして、一番右の山からも同じように調べていくと、中央の部分で2つの探索が合流します。

このアイディアを使って、砂の山を左から右、右から左の2つの方向から見ていきます。

1. **スタート**: 両端から2本の指（左指と右指）を置きます。
2. **比較**: 左指の山と右指の山、どちらが低いか比べます。低い方の山は、その山より高い山が出てくるまでの間に水がたまる可能性があるからです。
3. **水の計算**: 低い方の山から次の山へ指を移動させながら、たまる水の量を計算します。どれだけ水がたまるかは、低い山の高さと次の山の高さの差になります。
4. **繰り返し**: 左指と右指が交差するまで、2と3のステップを繰り返します。

この方法で、各位置にどれだけの水がたまるかを効率的に計算することができます！

--- 

このように、砂場での遊びをイメージすることで、この問題の解法の考え方をシンプルに理解することができます。
"""

"""
`trap`関数のアルゴリズムを、与えられた`height = [0,1,0,2,1,0,1,3,2,1,2,1]`に適用してシミュレーションを行います。

1. 初期設定:
```
l = 0, r = 11 (len(height) - 1)
leftMax = 0, rightMax = 1
res = 0
```

2. `l < r` の間、以下のステップを繰り返します:

2.1. 最初のステップ:
```
height[l] = 0, height[r] = 1
leftMax < rightMax (0 < 1) なので、lを右に移動。
leftMax = max(leftMax, height[l]) = max(0, 1) = 1
res += 1 - 1 = 0
l = 1
```

2.2. 次のステップ:
```
height[l] = 1, height[r] = 1
leftMax = rightMax (1 = 1) なので、rを左に移動。
rightMax = max(rightMax, height[r]) = max(1, 2) = 2
res += 2 - 2 = 0
r = 10
```

2.3. 次のステップ:
```
height[l] = 1, height[r] = 2
leftMax < rightMax (1 < 2) なので、lを右に移動。
leftMax = max(leftMax, height[l]) = max(1, 0) = 1
res += 1 - 0 = 1
l = 2
```

2.4. 次のステップ:
```
height[l] = 0, height[r] = 2
leftMax < rightMax (1 < 2) なので、lを右に移動。
leftMax = max(leftMax, height[l]) = max(1, 2) = 2
res += 2 - 2 = 0 (合計は1)
l = 3
```

2.5. 次のステップ:
```
height[l] = 2, height[r] = 2
leftMax = rightMax (2 = 2) なので、rを左に移動。
rightMax = max(rightMax, height[r]) = max(2, 1) = 2
res += 2 - 1 = 1 (合計は2)
r = 9
```

このプロセスを続けていきます。

最終的な`res`は6になります。この6は、指定された`height`配列にトラップされる雨水の合計量を示しています。
"""