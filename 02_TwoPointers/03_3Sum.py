from typing import List

# return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
def threeSum(nums: List[int]) -> List[List[int]]:
    res = []
    nums.sort()

    for i, a in enumerate(nums):
        if a > 0:
            break
        if i > 0 and a == nums[i-1]:
            continue

        l, r = i + 1, len(nums) - 1
        while l < r:
            three = a + nums[l] + nums[r]
            if three > 0:
                r -= 1
            elif three < 0:
                l += 1
            elif three == 0:
                res.append([a,nums[l],nums[r]])
                l += 1
                r -= 1
                while nums[l] == nums[l-1] and l < r:
                    l += 1
    return res

nums = [-1,0,1,2,-1,-4]
print(threeSum(nums))

"""
このコードは、整数のリストから3つの数を選び、それらの合計が0になるすべてのユニークな組み合わせを探す問題のためのものです。具体的には、`threeSum`という関数が与えられており、その関数内でいくつかの手続きが行われています。

**大まかな説明**:
1. 与えられたリスト`nums`を昇順にソートします。
2. ソート済みのリストを順番に走査し、各整数について3つの数の合計が0になる組み合わせを探索します。
3. 合計が0になる組み合わせを結果のリスト`res`に追加します。
4. 全ての整数を走査した後、`res`を返します。

**部分毎の説明**:
1. `res = []` & `nums.sort()`: 
   - `res`は結果を格納するためのリストを初期化しています。
   - `nums.sort()`でリストを昇順にソートしています。

2. `for i, a in enumerate(nums):`:
   - `nums`の各要素をインデックスと共に取り出します。

3. `if a > 0: break`:
   - 0より大きい整数は、合計が0になる組み合わせの一部として考慮する必要がないので、ループを終了します。

4. `if i > 0 and a == nums[i - 1]: continue`:
   - 連続する同じ値の整数をスキップします。これは、重複した結果を避けるためのものです。

5. `l, r = i + 1, len(nums) - 1`: 
   - 二つのポインタ`l`と`r`を初期化します。これらのポインタは、`a`と組み合わせて合計が0になる2つの数を探すために使います。

6. `while l < r:`:
   - `l`と`r`の間にある全ての整数のペアに対して、以下の操作を繰り返します。

7. `threeSum = a + nums[l] + nums[r]`:
   - 現在の3つの整数の合計値を計算します。

8. 次の`if`、`elif`、`else`ブロックは、`threeSum`の値に応じて、ポインタ`l`と`r`を適切に動かします。具体的には、
   - `threeSum > 0`: `r`をデクリメントして合計を小さくします。
   - `threeSum < 0`: `l`をインクリメントして合計を大きくします。
   - 合計が0の場合、結果を`res`に追加し、`l`と`r`の両方を動かして次の組み合わせを探します。

9. `while nums[l] == nums[l - 1] and l < r`: 
   - 重複した結果を避けるために、同じ値の整数をスキップします。

最後に、すべての組み合わせを探索した後、`res`を返して結果を得ます。
"""

"""
`threeSum`のようなアルゴリズムを考え出すためには、次のようなステップやアプローチが役立ちます：

1. **問題の理解**: 問題を完全に理解し、求められていることや入力の制約を確認します。この場合、リスト内の3つの数の合計が0になるすべてのユニークな組み合わせを見つけることが求められています。

2. **単純化**: 問題をもっと簡単なバージョンに単純化して考えてみます。たとえば、`threeSum`の前に`twoSum`の解を考えることができます。この単純な問題に対する解法を理解することで、より複雑な問題の解法を洞察する手助けとなります。

3. **ブルートフォースの解**: 最初は最も直感的な方法で解を探してみます。この場合、3つの数字を選ぶ全ての組み合わせを試すブルートフォースの方法が考えられます。しかし、この方法は効率的ではないため、次のステップで最適化を考えます。

4. **最適化の考慮**: ブルートフォースの方法を最適化するための方法を考えます。この場合、リストをソートして、二つのポインタを使用する方法が有効です。ソートされたリストでは、小さい数と大きい数を効果的に比較して、目的の合計に近づけることができます。

5. **重複の排除**: 重複する解を避けるために、連続する同じ数字をスキップするなどの方法を導入します。

6. **実装とテスト**: アルゴリズムを実装し、いくつかのテストケースでそれを試します。このステップでは、コードが正しく動作するかどうかを確認するとともに、さらなる最適化のアイディアが浮かぶかもしれません。

7. **フィードバックループ**: 他の人々の解法を学ぶことで、新しいテクニックや方法を学び、自分のアルゴリズム思考を向上させます。

上記のステップやアプローチは、新しい問題や未知の問題に取り組む際の一般的なガイドラインとして使用できます。繰り返し練習することで、アルゴリズムの設計や最適化のスキルを向上させることができます。
"""

"""
もちろん、`threeSum`関数を用いて、`nums = [-1, 0, 1, 2, -1, -4]` のシミュレーションを手順ごとに行います。

1. **初期化**:  
`res` = [] （結果を保存するリストを初期化）  
`nums`をソートする ⇒ `nums` = [-4, -1, -1, 0, 1, 2]

2. **外側のループ**（`i`を0から始めてリストをループする）:

    - i=0, a=-4  
      aが0より大きいかチェック ⇒ False  
      i>0 かつ aが前の数字と同じかチェック ⇒ False（i=0なので）  
      l = i + 1 = 1, r = 5 として内側のループに入る。

      しかし、この場合、a + nums[l] + nums[r] = -4 -1 + 2 = -3 が0より小さいため、他の組み合わせも0未満になります。したがって、この`a=-4`の場合は何も見つからないことが確定します。

    - i=1, a=-1  
      aが0より大きいかチェック ⇒ False  
      i>0 かつ aが前の数字と同じかチェック ⇒ False  
      l = i + 1 = 2, r = 5 として内側のループに入る。

      a + nums[l] + nums[r] = -1 -1 + 2 = 0 です。これは0と一致します。したがって、[-1, -1, 2]を`res`に追加します。

      次に、lとrの両方を移動させます。l = 3, r = 4 になります。  
      そして、`nums[l]`が前の`nums[l]`と同じかどうかをチェックしますが、`nums[3]`と`nums[2]`は異なるので、特にアクションは取られません。

      この時点で、lはrよりも小さいので、内側のループを続行します。  
      a + nums[l] + nums[r] = -1 + 0 + 1 = 0 です。これは0と一致します。したがって、[-1, 0, 1]を`res`に追加します。

    - i=2, a=-1  
      aが0より大きいかチェック ⇒ False  
      i>0 かつ aが前の数字と同じかチェック ⇒ True（`nums[2]`は`nums[1]`と同じです）  
      したがって、このループはスキップされます。

    - i=3, a=0  
      aが0より大きいかチェック ⇒ False  
      i>0 かつ aが前の数字と同じかチェック ⇒ False  
      l = i + 1 = 4, r = 5 として内側のループに入る。

      しかし、a + nums[l] + nums[r] = 0 + 1 + 2 = 3 が0より大きいため、他の組み合わせも0以上になります。したがって、この`a=0`の場合は何も見つからないことが確定します。

    - i=4、a=1  
      aが0より大きいかチェック ⇒ True  
      この時点で外側のループを終了します。

最終的な`res` = [[-1, -1, 2], [-1, 0, 1]]

以上の手順に従って、`nums = [-1, 0, 1, 2, -1, -4]`の`threeSum`の結果は、`[[-1, -1, 2], [-1, 0, 1]]`です。
"""