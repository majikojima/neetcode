from typing import List

def maxArea(height: List[int]) -> int:
    l, r = 0, len(height) - 1
    res = 0

    while l < r:
        res = max(res, min(height[l], height[r]) * (r - l))
        if height[l] < height[r]:
            l += 1
        elif height[l] >= height[r]:
            r -= 1
    return res

height = [1,8,6,2,5,4,8,3,7]
print(maxArea(height))

"""
この関数は、コンテナが最大の水を保持することができる2つの位置を見つけるためのアルゴリズムです。コンテナの壁は`height`リストで与えられ、i番目の位置にある壁の高さは`height[i]`です。水の量は、2つの壁の間の距離と、その2つの壁のうち短い方の高さによって決まります。

大まかな説明：
1. 2つのポインタ`l`と`r`をリストの最初と最後に設定します。
2. `l`と`r`が交差するまで、次のいずれかの操作を繰り返します：
    - `l`と`r`の位置にある壁の間で保持できる水の量を計算し、これが現在の最大値よりも大きければ更新します。
    - 2つの壁のうち短い方の壁の方向にポインタを移動させます。
3. 最大の水の量を返します。

部分毎の説明：
1. `l, r = 0, len(height) - 1`: 2つのポインタ`l`と`r`をリストの最初と最後に設定します。
2. `res = 0`: 最大の水の量を保存するための変数を初期化します。
3. `while l < r`: このループは`l`と`r`が交差するまで続けられます。
4. `res = max(res, min(height[l], height[r]) * (r - l))`: 現在の2つの壁の間で保持できる水の量を計算し、これが現在の最大値よりも大きければ更新します。
5. `if height[l] < height[r]: l += 1`：左側の壁が右側の壁よりも短ければ、左側のポインタを1つ進めます。
6. `elif height[r] <= height[l]: r -= 1`：右側の壁が左側の壁と同じか、左側の壁よりも短ければ、右側のポインタを1つ戻します。
7. `return res`: 最大の水の量を返します。

このアルゴリズムの基本的な考え方は、最初に最も遠い2つの壁を選び、それから短い方の壁を移動させながら最大の容量を見つけることです。短い方の壁を移動させる理由は、高い方の壁を移動させても容量が増えることはないためです。
"""

"""
指定された式 `res = max(res, min(height[l], height[r]) * (r - l))` には、いくつかの基本的な数学的・プログラム的操作が含まれています。これを詳しく解説いたします。

1. `min(height[l], height[r])`: 
   - `height[l]` と `height[r]` は、`height` リストの `l` 番目と `r` 番目の要素を指しています。
   - `min` 関数は、その2つの要素のうち小さい方を返します。
   - この操作の目的は、2つの壁の間で形成されるコンテナの高さを確定するためです。この高さは、2つの壁のうち短い方に等しいため、この関数を使用して短い方の高さを取得します。

2. `(r - l)`:
   - `r` と `l` は2つの位置を示しています。
   - この部分は、2つの壁の間の距離を計算しています。

3. `min(height[l], height[r]) * (r - l)`:
   - 上述の2つの結果を乗算しています。
   - この結果は、2つの壁の間に保持される水の量を示しています。水の量は、壁の高さ（短い方の壁）と2つの壁の間の距離によって決まります。

4. `max(res, min(height[l], height[r]) * (r - l))`:
   - `max` 関数は、`res`（これまでに計算された最大の水の量）と、現在の2つの壁の間に保持される水の量のうち、大きい方を返します。
   - これにより、新たに計算された水の量がこれまでの最大値よりも大きい場合、最大値が更新されます。

5. `res =`:
   - これは、`res` 変数に `max` 関数の結果を代入しています。これにより、`res` は常にこれまでに計算された最大の水の量を保持しています。
"""

"""
このアルゴリズム（`maxArea`関数）を考える際のアプローチやロジックの背後にある考え方を以下に説明します。

**問題の理解：**
- 最初に問題をよく理解します。この場合、2つの線を選んで、それらの線とx軸との間に形成される領域の面積を最大化したいと考えます。ここで、線の間の距離と、選択された線の最小の高さの積が面積となります。

**総当たりのアプローチ：**
- 最も単純な方法は、全てのペアの組み合わせを試す総当たりのアプローチです。しかし、これは時間がかかりすぎるため、より効率的な方法を探求します。

**効率的なアプローチの考察：**
- 線の間の距離が広がるほど、面積が大きくなる可能性があると考えます。しかし、面積は線の高さ（特に短い方の高さ）にも依存しています。
- この情報をもとに、左端と右端の2つのポインタを考えます。最初は最も距離が離れている状態から始めて、徐々に狭めていきます。

**アルゴリズムの構築：**
1. 左ポインタ`l`と右ポインタ`r`を初期化します。`l`は0、`r`はリストの最後のインデックスになります。
2. `l`と`r`の指す線の高さを比較します。低い方の線が面積に制約をかけているため、その線を動かすことを考えます。もし左側の線が低ければ、`l`を1つ増やします。逆に、右側の線が低ければ、`r`を1つ減らします。
3. このプロセスを`l`が`r`よりも小さい間、続けます。

**最適性の理由：**
- このアルゴリズムは2つのポインタが互いに向かって動くため、各ステップで少なくとも1つの選択肢が削除され、全ての可能性を効率的に試すことができます。

このように、問題の性質や特徴を深く理解することで、効率的なアルゴリズムや解法を導き出すことができます。
"""

"""
了解しました。`height = [1,8,6,2,5,4,8,3,7]` という入力で、`maxArea`関数の動作をシミュレーションしていきます。

1. 初期状態：
   ```
   height = [1,8,6,2,5,4,8,3,7]
   l = 0, r = 8 (リストの最後のインデックス)
   res = 0 (最大面積を保存する変数)
   ```

2. 最初のステップ：  
   lの位置の高さ = 1, rの位置の高さ = 7  
   `min(1, 7) * (8 - 0) = 1 * 8 = 8`  
   `res = max(0, 8) = 8`  
   1 < 7 なので、lを1つ増やします。

3. 次のステップ：
   ```
   l = 1, r = 8
   ```
   lの位置の高さ = 8, rの位置の高さ = 7  
   `min(8, 7) * (8 - 1) = 7 * 7 = 49`  
   `res = max(8, 49) = 49`  
   7 < 8 なので、rを1つ減らします。

4. 次のステップ：
   ```
   l = 1, r = 7
   ```
   lの位置の高さ = 8, rの位置の高さ = 3  
   `min(8, 3) * (7 - 1) = 3 * 6 = 18`  
   `res = max(49, 18) = 49`  
   3 < 8 なので、rを1つ減らします。

5. 次のステップ：
   ```
   l = 1, r = 6
   ```
   lの位置の高さ = 8, rの位置の高さ = 8  
   `min(8, 8) * (6 - 1) = 8 * 5 = 40`  
   `res = max(49, 40) = 49`  
   8 = 8 なので、どちらのポインタを動かしても良いが、コードの実装に従い、rを1つ減らします。

これを続けると、lとrが交差するまでの間、最大面積は49であることがわかります。

したがって、この入力に対する`maxArea`関数の出力は49です。
"""