from typing import List

def dailyTemperatures(temperatures: List[int]) -> List[int]:
    res = [0] * len(temperatures)
    stack = [] # pair [temp, index]

    for i, t in enumerate(temperatures):
        while stack and t > stack[-1][0]:
            stackT, stackI = stack.pop()
            res[stackI] = i - stackI
        stack.append((t, i))
    return res

temperatures = [73,74,75,71,69,72,76,73]
print(dailyTemperatures(temperatures))

"""
このコードは、先ほどの「日々の気温」問題を解くためのものです。与えられた`temperatures`リストに基づいて、より暖かい日までの待ち日数を計算します。

**大まかな説明**:
- 入力された`temperatures`リストに対して、各日の気温が次に上昇するまでの日数を計算し、その結果を`res`リストに格納して返します。
- コードはスタックを使用してこの計算を効率的に行います。

**部分毎の説明**:

1. `res = [0] * len(temperatures)`
   - `res`は最終的な答えを格納するリストです。初期化では、全要素を0にしています。これはデフォルトで、より暖かい日が存在しない場合の待ち日数が0であることを意味します。

2. `stack = []  # pair: [temp, index]`
   - スタックを初期化します。このスタックは、未来に暖かい日を探している各日の気温と、その日のインデックスのペアを保持します。

3. `for i, t in enumerate(temperatures):`
   - `temperatures`リストを順番に走査します。`i`は現在の日のインデックス、`t`はその日の気温です。

4. `while stack and t > stack[-1][0]:`
   - スタックが空でない、かつ、現在の日の気温`t`がスタックのトップにある日の気温よりも高い場合、このループが実行されます。

5. `stackT, stackInd = stack.pop()`
   - スタックのトップから気温とその日のインデックスのペアを取り出します。

6. `res[stackInd] = i - stackInd`
   - 現在の日とスタックのトップにあった日との差（日数）を計算し、`res`リストの対応するインデックスに保存します。

7. `stack.append((t, i))`
   - 現在の日の気温とインデックスのペアをスタックにプッシュします。これにより、この日が未来に暖かい日を探していることを示します。

8. `return res`
   - 計算された待ち日数を含むリスト`res`を返します。

このアルゴリズムは、スタックの特性を活用して、`temperatures`リストを1回の走査で効率的に処理します。
"""

"""
この問題文は、特定の条件に基づいて新しい配列を作成するためのガイダンスを示しています。問題を要点に分解してみましょう。

1. **入力**:
    - `temperatures`: 日々の気温を表す整数の配列。

2. **出力**:
    - `answer`: `temperatures`と同じ長さを持つ配列。`answer[i]`は、`temperatures[i]`の日から数えて何日後に気温が上昇するかを示す整数です。

3. **条件**:
    - もし`temperatures[i]`より暖かい日がこれから訪れない場合、`answer[i]`は0になります。

4. **目的**:
    - ある日`i`の気温に比べて、より暖かい日が最初に訪れるまでの日数を`answer`配列の対応するインデックスに格納することです。

**具体的な手順の例**:

入力として、`temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`が与えられた場合、解は以下のようになります：

1. 最初の日`73`度：次の日に`74`度と暖かくなるので、答えは`1`
2. 2日目`74`度：次の日に`75`度と暖かくなるので、答えは`1`
3. 3日目`75`度：次により暖かい`76`度の日までに`4`日かかるので、答えは`4`
4. 4日目`71`度：2日後に`72`度と暖かくなるので、答えは`2`
5. 5日目`69`度：翌日に`72`度と暖かくなるので、答えは`1`
6. 6日目`72`度：翌日に`76`度と暖かくなるので、答えは`1`
7. 7日目`76`度：これ以降、より暖かい日はないので、答えは`0`
8. 8日目`73`度：これ以降、より暖かい日はないので、答えは`0`

結果、`answer = [1, 1, 4, 2, 1, 1, 0, 0]`となります。

この問題を効率的に解くためには、スタックを利用する方法が一般的です。スタックを使用して、まだより暖かい日を探している日々の気温を管理し、より暖かい日が見つかった時にその日までの差（日数）を計算します。
"""

"""
スタックを使用してこの問題を効率的に解く理由は、スタックの「Last In, First Out」(LIFO)の性質が、日々の気温を確認しながらより暖かい日を見つけるプロセスに合致しているためです。

以下は、スタックを使用する方法が効率的である理由を具体的に説明します：

1. **逐次的な比較**:
   - 配列を左から右へと進めながら、各日の気温を順番に確認します。これは、未来の気温が過去の気温より高いかどうかを確認する際に、現在と未来の日を簡単に比較できるようにするためです。

2. **過去の日々の保持**:
   - 未来の日が現在の日より暖かいかどうかを確認する際に、これまでの日々の気温をスタックに保存します。これにより、未来の日が過去のいくつかの日よりも暖かい場合、それらの日々の答えをすぐに計算できます。

3. **LIFOの性質**:
   - スタックのLIFOの性質により、現在の日がスタックのトップにある日よりも暖かい場合、スタックのトップの日は「より暖かい日」を見つけたということになります。そのため、その日の答えを計算し、スタックからその日を取り除くことができます。このプロセスを、現在の日がスタックのトップの日よりも暖かくない日が見つかるまで繰り返します。

4. **効率性**:
   - スタックを使用すると、各日の気温は最大で2回しかスタックにアクセスされません（一度はプッシュ、一度はポップ）。このため、アルゴリズムの時間計算量はO(n)となり、非常に効率的です。

以上の理由から、スタックを使用してこの問題を解く方法は、他のアプローチ（例えば、2つのループを使用して各日の気温を比較する方法）よりも効率的であり、一般的に推奨されるアプローチとなっています。
"""

"""
アルゴリズムやデータ構造を設計する能力は、時間とともに経験を積むことで養われるものです。以下は、アルゴリズムを設計するためのスキルを向上させるための一般的な方法と推奨事項です：

1. **基本的なデータ構造とアルゴリズムを理解する**:
   - まず、基本的なデータ構造（配列、リンクリスト、スタック、キュー、ツリー、グラフなど）とその操作、および基本的なアルゴリズム（ソート、検索、再帰、バックトラッキング、動的計画法など）に精通することが重要です。

2. **問題解決の実践**:
   - アルゴリズムの問題を多く解くことで、ある種の問題のパターンや、特定のデータ構造が適している場面を自然に感じ取ることができるようになります。コードチャレンジサイトや競技プログラミングのサイトを利用して練習するのがおすすめです。

3. **問題を分解する**:
   - 複雑な問題に直面したとき、その問題を小さな部分やサブタスクに分解することで、それぞれの部分を解決する方法を考えるのが楽になります。

4. **手でシミュレーションする**:
   - 問題やデータ構造の動作を紙やホワイトボード上で手動でシミュレーションすることで、どのように動作するのか、どこに問題があるのかを明確に理解することができます。

5. **他人のソリューションを学ぶ**:
   - 他の人が同じ問題にどのようなアプローチで取り組んでいるのかを学ぶことで、新しいテクニックや方法を学ぶことができます。

6. **フィードバックを求める**:
   - 自分の解決策を他の人に見せてフィードバックを受け取ることで、より良い解決方法や最適化の方法を学ぶことができます。

7. **持続的な学び**:
   - 新しいアルゴリズムやデータ構造、または最新の研究論文などを読むことで、常に最新の知識を持っていることが重要です。

アルゴリズムやデータ構造の設計は、継続的な学習と練習によって向上します。始めは難しいかもしれませんが、経験を積むことで自然とスキルが向上していきます。
"""