from typing import List

def productExceptSelf(nums: List[int]) -> List[int]:
    result = [1] * (len(nums))
    prefix = 1
    for i in range(len(nums)):
        result[i] = prefix
        prefix *= nums[i]

    postfix = 1
    for i in range(len(nums) - 1, -1, -1):
        result[i] *= postfix
        postfix *= nums[i]

    return result

nums = [1,2,3,4]
result = productExceptSelf(nums)

print(result)

"""
このコードは、与えられたリスト `nums` の各要素について、その要素を除いた他の全要素の積を求めるものです。具体的には、`nums` が `[a, b, c, d]` の場合、戻り値は `[b*c*d, a*c*d, a*b*d, a*b*c]` となります。

コードの動作の理解のために、以下に詳しい説明を行います。

1. **初期設定**:
   - `result` リストを長さ `len(nums)` だけの1のリストとして初期化します。これは、各要素の積を保存するためのリストとなります。

2. **前方の積計算**:
   - `prefix` を 1 として初期化します。これは、今までの積を保存する変数です。
   - `nums` の各要素に対して、`prefix` を `result` に保存し、`prefix` を現在の数値で更新します。
   - このループが終了すると、`result` は各位置におけるその位置までの前方の要素の積を保持します。

3. **後方の積計算**:
   - `postfix` を 1 として初期化します。これも、今までの積を保存する変数ですが、今回は後方の要素に対して計算します。
   - `nums` の各要素に対して、後ろから前に向かって、`postfix` を `result` に乗算して更新し、`postfix` も現在の数値で更新します。
   - このループが終了すると、`result` は各位置におけるその位置の前方の要素の積と後方の要素の積の積を保持します。

このアルゴリズムを考えるためのヒントとして、要素の積を求める際に、その要素を除く方法として、前方の要素の積と後方の要素の積を個別に計算し、最後にこれらを乗算する方法を採用しています。このアプローチをとることで、全体としての計算量が効率的になります。
"""

"""
了解しました。アルゴリズムの背後にある考え方を分かりやすく説明します。

### 問題の背景

まず、問題の背景として、リストの各要素について、その要素を除いた他のすべての要素の積を求める必要があります。例えば、`nums = [a, b, c, d]` の場合、答えは以下の通りになります：

1. aを除いた他の要素の積: `b * c * d`
2. bを除いた他の要素の積: `a * c * d`
3. cを除いた他の要素の積: `a * b * d`
4. dを除いた他の要素の積: `a * b * c`

### 前方と後方の積の考え方

上記の計算を各要素に対して直接行うと、計算量が増大する恐れがあります。そこで、効率的な方法として、「前方の積」と「後方の積」を使用するアイディアが登場します。

- **前方の積**：ある要素の前にある要素すべての積です。例えば、`c` に対しては `a * b`。
- **後方の積**：ある要素の後にある要素すべての積です。例えば、`b` に対しては `c * d`。

これらの考え方を使用すると、`c` の答え（`a * b * d`）は、「cの前方の積」(`a * b`) と「cの後方の積」(`d`) を乗算することで得られます。

### アルゴリズムのステップ

1. **前方の積の計算**: `result` リストは初めてのループで「前方の積」を保存します。このループを進めると、`result` は各位置でその位置までの要素の積を持ちます。
  
2. **後方の積の計算**: 次のループでは、`result` の各位置を「後方の積」で更新します。このループを進めると、`result` は各位置でその位置の前方と後方の要素の積を持ちます。

このように、2つのループだけで答えを効率的に計算することができます。
"""