from typing import List

def rob(nums: List[int]) -> int:
    rob1, rob2 = 0, 0

    for n in nums:
        temp = max(n + rob1, rob2)
        rob1 = rob2
        rob2 = temp
    return rob2

nums = [1,2,3,1]
print(rob(nums))

nums = [2,7,9,3,1]
print(rob(nums))

"""
このコードは、いわゆる「House Robber」の問題を解くためのものです。問題の内容は、盗賊が並ぶ家を盗む際、隣接した家を盗むと警報が鳴るため、最も多くのお金を盗む組み合わせを見つけることです。ここでの目標は、隣接しない家を選ぶことで最大の利益を得ることです。

**大まかな説明**:
このアルゴリズムは、動的計画法を利用しています。各ステップで、現在の家を盗むか前の家を盗むか、どちらが最も利益が大きいかを評価し、最適な選択を更新します。

**部分毎の説明**:

1. `rob1, rob2 = 0, 0`:
    - `rob1`と`rob2`は、それぞれ1つ前と2つ前の家を盗んだ際の最大の利益を保持します。

2. `for n in nums`:
    - 各家（`nums`の各要素）についてループを回します。

3. `temp = max(n + rob1, rob2)`:
    - 現在の家を盗む場合（`n + rob1`）と盗まない場合（`rob2`）のうち、どちらがより多くの利益をもたらすかを評価します。

4. `rob1 = rob2`:
    - 1つ前の家を盗んだ際の最大の利益の情報を更新します。

5. `rob2 = temp`:
    - 2つ前の家を盗んだ際の最大の利益の情報を更新します。

6. `return rob2`:
    - 全ての家を考慮した後、`rob2`は最大の利益を持っているので、それを返します。

要するに、このアルゴリズムは、各ステップで最適な選択を更新することで、最終的に最大の利益を得る方法を見つけます。
"""