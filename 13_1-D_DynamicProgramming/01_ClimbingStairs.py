class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 3:
            return n
        
        n1, n2 = 2, 3

        for i in range(4, n+1):
            temp = n1 + n2
            n1 = n2
            n2 = temp
        
        return n2
    
s = Solution()
n = 3
result = s.climbStairs(n)
print(result)

"""
このコードは、階段を上る異なる方法の数を計算するものです。あなたは一度に1段または2段の階段を上ることができます。この問題は典型的な動的計画法(Dynamic Programming)の問題で、このコードはそれを使って解いています。

1. `class Solution:` Pythonのクラスであり、様々な関数や属性をまとめて保管します。このクラスでは、階段を上る異なる方法を計算する関数を定義しています。

2. `def climbStairs(self, n: int) -> int:` この関数は、与えられた階段数`n`に対して、異なる上り方の数を返すものです。

3. `if n <= 3: return n` この行は、階段が3段以下の場合、その段数（`n`）が異なる上り方の数となることを指しています（1段なら1通り、2段なら2通り、3段なら3通り）。

4. `n1, n2 = 2, 3` この行は、階段が4段以上の場合に使用する2つの変数`n1`と`n2`を初期化しています。`n1`は、現在の段数-2の位置から上る方法の数を、`n2`は現在の段数-1の位置から上る方法の数をそれぞれ保持します。

5. `for i in range(4, n+1):` この行は、階段が4段以上の場合に、各段数ごとに異なる上り方の数を計算するループを開始します。

6. `temp = n1 + n2` この行では、現在の段数に対する上り方の総数を計算しています。これは、現在の段数-1の位置（`n2`）と現在の段数-2の位置（`n1`）から上る方法の数を合計したものです。

7. `n1 = n2` そして、次のループの準備として、`n1`（現在の段数-2の位置からの上り方の数）を更新します。ここでは、`n1`に`n2`の値（現在の段数-1の位置からの上り方の数）を代入しています。

8. `n2 = temp` 同様に、次のループの準備として`n2`（現在の段数-1の位置からの上り方の数）を更新します。ここでは、`n2`に`temp`の値（現在の段数に対する上り方の総数）を代入しています。

9. `return n2` 最後に、`n2`を返します。この`n2`は、与えられた段数`n`に対する上り方の総数となります。
"""

"""
それでは、まず入力が4の場合を見てみましょう。

1. `n1, n2 = 2, 3`: 最初の2つの変数は、それぞれ2と3で初期化されます。つまり、階段が2段の場合の上り方の数（2通り）と、階段が3段の場合の上り方の数（3通り）です。

2. `for i in range(4, 4+1):` このループは4から5（5は除外）までの範囲で実行されます。つまり、このループは1回だけ実行されます。

3. `temp = n1 + n2`: `temp`は`n1`と`n2`の合計で、これは2+3=5になります。つまり、階段が4段の場合の上り方の数は5通りになります。

4. `n1 = n2`: `n1`を更新して`n2`の値（3）にします。

5. `n2 = temp`: `n2`を更新して`temp`の値（5）にします。

6. `return n2`: `n2`（5）を返します。これが階段が4段の場合の上り方の総数です。

次に、入力が5の場合を見てみましょう。

1. `n1, n2 = 2, 3`: 最初の2つの変数は、それぞれ2と3で初期化されます。

2. `for i in range(4, 5+1):` このループは4から6（6は除外）までの範囲で実行されます。つまり、このループは2回実行されます。

3. 第1回目のループで、`temp = n1 + n2`: `temp`は2+3=5になります。階段が4段の場合の上り方の数は5通りになります。

4. `n1 = n2`: `n1`を更新して`n2`の値（3）にします。

5. `n2 = temp`: `n2`を更新して`temp`の値（5）にします。

6. 第2回目のループで、`temp = n1 + n2`: `temp`は3+5=8になります。階段が5段の場合の上り方の数は8通りになります。

7. `n1 = n2`: `n1`を更新して`n2`の値（5）にします。

8. `n2 = temp`: `n2`を更新して`temp`の値（8）にします。

9. `return n2`: `n2`（8）を返します。これが階段が5段の場合の上り方の総数です。
"""

"""
このアルゴリズムは、ダイナミックプログラミングという手法を用いています。具体的には、`n`段の階段の上り方の数を計算するために、`n-1`段と`n-2`段の階段の上り方の数を利用します。これは、ある段数`n`の階段に到達するための最後の一歩は、`n-1`から一段上るか、あるいは`n-2`から二段上るか、の二通りしかないという事実に基づいています。

したがって、`n`段の階段の上り方の数は、`n-1`段の階段の上り方の数（一段ずつ上る）と`n-2`段の階段の上り方の数（二段ずつ上る）の合計になります。この関係性はフィボナッチ数列と同じで、それぞれの数がその直前の二つの数の合計であるという性質を利用しています。

このアルゴリズムでは、`n1`と`n2`という二つの変数を用いて、`n-2`段と`n-1`段の階段の上り方の数を保持します。そして、`temp`という変数にその合計を計算し、その結果を`n2`に更新します。その後、`n1`と`n2`を一つずつシフトして、次のループの準備を行います。これを`n`まで繰り返すことで、`n`段の階段の上り方の数を計算します。

例えば、階段が5段の場合、その上り方の数は、4段の階段の上り方の数（一段ずつ上る）と3段の階段の上り方の数（二段ずつ上る）の合計、つまり5通りと3通りを合わせた8通りになります。
"""