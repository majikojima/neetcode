from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(len(cost) - 3, -1, -1):
            cost[i] += min(cost[i + 1], cost[i + 2])
            print(cost)

        return min(cost[0], cost[1])
    
s = Solution()
cost = [10,15,20]
result = s.minCostClimbingStairs(cost)
print(result)

print("")
cost = [1,100,1,1,1,100,1,1,100,1]
result = s.minCostClimbingStairs(cost)
print(result)
"""
この関数は、与えられた`cost`リストに基づいて階段を登る最小のコストを返すものです。階段を一段ずつまたは二段ずつ登ることができ、それぞれの段には特定のコストがあります。リストの各要素は、そのインデックスの段を登るのに必要なコストを表します。

1. `for i in range(len(cost) - 3, -1, -1):`：このループは、`cost`リストの末尾から3つ目の要素から始まり、先頭の要素まで逆順に各要素にアクセスします。この手法はダイナミックプログラミングの一種で、この場合では、各段に到達するための最小コストを順次計算します。

2. `cost[i] += min(cost[i + 1], cost[i + 2])`：各段に到達するための最小コストを計算します。ある段`i`に到達するためには、前の段`i + 1`を登るか、前の前の段`i + 2`を登るかのどちらか一方が必要となります。この行では、これらの二つの選択肢のうちコストが小さい方を選び、それを段`i`のコストに加えます。これにより、段`i`に到達するための最小コストが更新されます。

3. `return min(cost[0], cost[1])`：最後に、先頭の二つの要素、つまり一番下の段と二番目の段からスタートした場合のコストを比較し、それらのうち小さい方を返します。これは、スタートする段を選べるため、最小のコストでゴールに到達できるスタート地点を選びます。

この関数の全体的な動作は、各段に到達するための最小コストを後ろから計算し、それに基づいて最初の二つの段のうちどちらからスタートするとコストが最小になるかを判断しています。
"""

"""
もちろんです！では、階段の昇り方についてのストーリーを考えてみましょう。

あなたは、各段にコストがついている階段を上るゲームをしています。各段を上るたびに、その段のコストだけエネルギーが減ります。あなたの目標は、一番上までエネルギーを使い切らないようにすることです。各段を1段ずつ、または2段ずつ上ることができます。

ここで重要なことは、2段先を見て、「次に1段上るべきか、2段上るべきか」を判断することです。1段上ると次の段のコストがかかり、2段上ると次の次の段のコストがかかります。そのため、次と次の次のどちらの段が低コストかを見て、低コストの段に進むことにします。それがこの部分の意味です：`cost[i] += min(cost[i + 1], cost[i + 2])`。

これを繰り返すと、最後には一番下の段（`cost[0]`）と二番目の段（`cost[1]`）のどちらからスタートすると最終的にエネルギーの消費が少ないかがわかります。だから最後に `return min(cost[0], cost[1])` という計算をしているのです。

ゲームを戦略的に進めるために、最初から最後まで全部計画するのではなく、その都度最善の選択をするという考え方は、プログラミングでは「グリーディ法」や「ダイナミックプログラミング」と呼ばれます。
"""