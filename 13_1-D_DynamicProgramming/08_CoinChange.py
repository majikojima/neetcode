from typing import List

def coinChange(coins: List[int], amount: int) -> int:
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0

    for a in range(1, amount + 1):
        for c in coins:
            if a - c >= 0:
                dp[a] = min(dp[a], 1 + dp[a - c])
    return dp[amount] if dp[amount] != amount + 1 else -1

coins = [1,2,5]
amount = 11
print(coinChange(coins, amount))

coins = [2]
amount = 3
print(coinChange(coins, amount))

"""
このコードは、与えられたコインの額面のリスト(`coins`)と目的の合計額(`amount`)を使用して、目的の合計額を達成するために必要なコインの最小数を求める問題の解決策を提供しています。このような問題は動的プログラミングを使用して効率的に解くことができます。

### 大まかな説明:

1. `dp`リストを初期化する。このリストの各要素は、そのインデックスの値を作成するために必要な最小のコイン数を表す。
2. `dp[0]`を`0`に設定する。合計が`0`の場合、必要なコインは`0`枚です。
3. 各金額に対して利用可能なすべてのコインを試す。
4. `dp[a]`は、金額`a`を作成するために必要な最小のコイン数を示す。
5. もし`dp[amount]`が`amount + 1`（最初に設定した最大値）と同じならば、その金額を作成することはできないため、`-1`を返す。

### 部分毎の説明:

- `dp = [amount + 1] * (amount + 1)`: 
    - `amount + 1`は取り得る最悪のシナリオ（つまり、`amount`を作る方法がない場合）を意味します。
    - 例: `amount = 11`, `coins = [5]` の場合、11を作成する方法は存在しないので、`dp[11]` は `12`（= `amount + 1`）となります。

- `dp[0] = 0`: 
    - 0の金額を得るためのコインは0枚です。

- `for a in range(1, amount + 1):`:
    - 1から`amount`までの各金額を試してみます。

- `for c in coins:`:
    - 使用可能なすべてのコインで、現在の金額`a`を作成することができるか試してみます。

- `if a - c >= 0:`:
    - 現在の金額からコインの価値を差し引いたときに、それが0以上であれば、そのコインを使用してその金額を作成することができます。

- `dp[a] = min(dp[a], 1 + dp[a - c])`:
    - 現在の金額`a`を作成するための最小のコイン数を更新します。それは、これまでに知られている最小のコイン数（`dp[a]`）と、コイン`c`を使ってその金額を作成するためのコイン数（`1 + dp[a - c]`）の小さい方となります。

- `return dp[amount] if dp[amount] != amount + 1 else -1`:
    - もし`dp[amount]`が`amount + 1`と同じならば、その金額を作成する方法は存在しないので`-1`を返します。そうでなければ、`dp[amount]`を返します。
"""

"""
`coins = [1,2,5]` と `amount = 11` でのシミュレーションを行います。

実行を開始:

1. `dp`は `[12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]` と初期化されます。
2. `dp[0] = 0` のため、 `dp` は `[0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]` になります。

次に、`a`が1から11までの各金額に対してループが開始されます。

- `a = 1`: `coins = [1,2,5]` の各コインを試します。
  - `c = 1`: `1 - 1 = 0` なので、`dp[1] = min(12, 1 + dp[0]) = 1`。
  - `c = 2` と `c = 5` はこの金額で使用できないのでスキップします。
  
  `dp`: `[0, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]`

- `a = 2`: 
  - `c = 1`: `2 - 1 = 1` なので、`dp[2] = min(12, 1 + dp[1]) = 2`。
  - `c = 2`: `2 - 2 = 0` なので、`dp[2] = min(2, 1 + dp[0]) = 1`。
  - `c = 5` はスキップ。

  `dp`: `[0, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12]`

このように、aの値が11になるまで、この手続きが繰り返されます。

`a = 11` のときの結果が最終的に求める値になります。

最終的な `dp` は以下のようになります:
`[0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]`

よって、`dp[11] = 3` です。これは、金額11を作成するために必要な最小のコイン数が3枚（5, 5, 1）であることを示しています。
"""