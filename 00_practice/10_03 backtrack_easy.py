from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    def backtrack(path):
        # 終了条件: pathの長さがnumsの長さと等しければ、一つの順列が完成
        if len(path) == len(nums):
            res.append(path[:])  # 結果リストに追加
            return

        for num in nums:
            if num in path:  # すでに選択された数字はスキップ
                continue
            # 数字を追加して再帰呼び出し
            path.append(num)
            backtrack(path)
            # 最後に追加した数字を取り除き、次の数字を試す
            path.pop()

    res = []
    backtrack([])
    return res

nums = [1,2,3]
print(permute(nums))

nums = [1]
print(permute(nums))

"""
もちろん、`nums = [1, 2, 3]` を用いてバックトラッキングのシミュレーションを行います。

初期状態:
```
nums = [1, 2, 3]
res = []
path = []
```

1. `path`がまだ空なので、最初の数字`1`を選びます。
```
path = [1]
```

1.1. `1`が選ばれたので、残りの数字`2`を選びます。
```
path = [1, 2]
```

1.1.1. `1`と`2`が選ばれたので、残りの数字`3`を選びます。
```
path = [1, 2, 3]
```
これで`path`の長さが`nums`と等しくなったので、`res`に`[1, 2, 3]`を追加し、直近の選択`3`を取り消します。

1.1.2. 他の組み合わせを探すために`2`を取り消します。次の数字`3`を選びます。
```
path = [1, 3]
```
そして、`2`を選びます。
```
path = [1, 3, 2]
```
これで再び`path`の長さが`nums`と等しくなったので、`res`に`[1, 3, 2]`を追加します。そして、直近の選択を取り消して、前の状態に戻ります。

1.2. 最初の選択`1`を取り消して、次の数字`2`を選びます。
同様の手順で、組み合わせ`[2, 1, 3]`と`[2, 3, 1]`を`res`に追加します。

1.3. そして、`2`を取り消して、`3`を選びます。
同様に、組み合わせ`[3, 1, 2]`と`[3, 2, 1]`を`res`に追加します。

最終的な結果:
```
res = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

これにより、`nums = [1, 2, 3]` の全ての順列を得ることができました。
"""