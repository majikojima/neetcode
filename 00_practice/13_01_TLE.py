def climbStairs(n: int) -> int:
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        return climbStairs(n - 1) + climbStairs(n - 2)

n = 5
print(climbStairs(n))

"""
問題は、階段を上る方法の数を計算するもので、一度に1段または2段上ることができます。それに対して、2つのアプローチが示されています。それぞれのアプローチについて、性能の違いとその理由を説明します。

1. **再帰的なアプローチ**:
   - この関数は、フィボナッチ数の再帰的な定義に基づいています。つまり、`f(n) = f(n-1) + f(n-2)`。
   - この方法の問題点は、同じ値に対して多くの再帰呼び出しを行うことです。これにより、計算量が指数的に増加してしまいます（具体的には、O(2^n)に近似します）。
   - その結果、nが大きくなると、非常に遅くなります。

2. **イテレーティブなアプローチ**:
   - この関数は、フィボナッチ数を連続して計算するための反復的な方法を使用しています。
   - 2つの変数`n1`と`n2`を使って、繰り返し処理で次の数を計算していきます。
   - この方法では、各値を一度だけ計算するため、計算量はO(n)です。
   - この方法は、再帰的な方法よりも非常に効率的です。

**なぜ2つ目の方法が効率的なのか**:
1つ目の方法では、同じ計算を何度も繰り返しています。例えば、n=5の場合、`climbStairs(3)`と`climbStairs(2)`を計算するために`climbStairs(1)`を2回計算する必要があります。nが大きくなると、この冗長な計算がさらに増えるため、非常に非効率的になります。

一方、2つ目の方法では、計算は前進するだけであり、過去の結果を再利用して新しい結果を計算します。そのため、各ステップでの計算量は一定であり、全体としてO(n)の計算量で問題を解決することができます。
"""